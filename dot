#!/usr/bin/env bash
set -euo pipefail

# Dotfiles management CLI
# Inspired by dmmulroy/.dotfiles

DOTFILES_DIR="${DOTFILES_DIR:-$HOME/.dotfiles}"
PACKAGES_DIR="$DOTFILES_DIR/packages"
SETTINGS_DIR="$DOTFILES_DIR/settings"
SCRIPTS_DIR="$DOTFILES_DIR/scripts"
BACKUP_DIR="$HOME/.dotfiles-backup"

# Managed symlink directories
SYMLINKS=(
    "$HOME/.config/nvim"
    "$HOME/.config/fish"
    "$HOME/.config/tmux"
    "$HOME/.config/ghostty"
    "$HOME/.config/git"
    "$HOME/.config/omf"
    "$HOME/.config/opencode"
    "$HOME/.claude"
)

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging helpers
info() { echo -e "${BLUE}[INFO]${NC} $1"; }
success() { echo -e "${GREEN}[OK]${NC} $1"; }
warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Check if command exists
has() { command -v "$1" &>/dev/null; }

# =============================================================================
# Bash Package Helpers
# =============================================================================

BASH_PACKAGES_FILE="$PACKAGES_DIR/bash-packages.json"
BASH_PACKAGES_PERSONAL_FILE="$PACKAGES_DIR/bash-packages.personal.json"
BASH_PACKAGES_WORK_FILE="$PACKAGES_DIR/bash-packages.work.json"

_ensure_bash_packages_file() {
    local file="$1"
    if [[ ! -f "$file" ]]; then
        echo "[]" > "$file"
    fi
}

_bash_package_exists() {
    local pkg="$1"
    local file="$2"
    _ensure_bash_packages_file "$file"
    jq -e --arg cmd "$pkg" 'any(.[]; .command == $cmd)' "$file" >/dev/null 2>&1
}

_add_bash_package() {
    local pkg="$1"
    local install_script="$2"
    local file="$3"
    _ensure_bash_packages_file "$file"
    local tmp
    tmp=$(jq --arg cmd "$pkg" --arg inst "$install_script" \
        '. + [{"command": $cmd, "install": $inst}]' "$file")
    echo "$tmp" > "$file"
}

_remove_bash_package() {
    local pkg="$1"
    local file="$2"
    _ensure_bash_packages_file "$file"
    local tmp
    tmp=$(jq --arg cmd "$pkg" 'map(select(.command != $cmd))' "$file")
    echo "$tmp" > "$file"
}

_get_profile() {
    local profile_file="$DOTFILES_DIR/.dotprofile"
    if [[ -f "$profile_file" ]]; then
        cat "$profile_file" | tr -d '[:space:]'
    else
        echo ""
    fi
}

_install_bash_packages() {
    info "Installing bash packages..."

    local profile
    profile=$(_get_profile)

    _process_bash_packages_file "$BASH_PACKAGES_FILE"

    if [[ "$profile" == "personal" && -f "$BASH_PACKAGES_PERSONAL_FILE" ]]; then
        _process_bash_packages_file "$BASH_PACKAGES_PERSONAL_FILE"
    elif [[ "$profile" == "work" && -f "$BASH_PACKAGES_WORK_FILE" ]]; then
        _process_bash_packages_file "$BASH_PACKAGES_WORK_FILE"
    fi
}

_process_bash_packages_file() {
    local file="$1"

    if [[ ! -f "$file" ]]; then
        return 0
    fi

    local count
    count=$(jq 'length' "$file")

    if [[ "$count" -eq 0 ]]; then
        return 0
    fi

    info "Processing $(basename "$file")..."

    local packages
    packages=$(jq -c '.[]' "$file")

    while IFS= read -r pkg_json; do
        local cmd install_script update_cmd
        cmd=$(echo "$pkg_json" | jq -r '.command')
        install_script=$(echo "$pkg_json" | jq -r '.install')
        update_cmd=$(echo "$pkg_json" | jq -r '.update // empty')

        if has "$cmd"; then
            if [[ -n "$update_cmd" ]]; then
                info "Updating $cmd..."
                echo "  Running: $update_cmd"
                if eval "$update_cmd"; then
                    success "Updated $cmd"
                else
                    warn "Failed to update $cmd (continuing...)"
                fi
            else
                success "$cmd already installed"
            fi
        else
            info "Installing $cmd..."
            echo "  Running: $install_script"
            if eval "$install_script"; then
                success "Installed $cmd"
            else
                warn "Failed to install $cmd (continuing...)"
            fi
        fi
    done <<< "$packages"
}

# =============================================================================
# Service Helpers
# =============================================================================

SERVICES_FILE="$SETTINGS_DIR/services.json"

_start_services() {
    if [[ ! -f "$SERVICES_FILE" ]]; then
        return 0
    fi

    local count
    count=$(jq 'length' "$SERVICES_FILE")
    if [[ "$count" -eq 0 ]]; then
        return 0
    fi

    info "Starting brew services..."

    local services
    services=$(jq -c '.[]' "$SERVICES_FILE")

    while IFS= read -r svc_json; do
        local name use_sudo
        name=$(echo "$svc_json" | jq -r '.name')
        use_sudo=$(echo "$svc_json" | jq -r '.sudo // false')

        # Check if service is already running
        local check_cmd is_running
        check_cmd=$(echo "$svc_json" | jq -r '.check // empty')

        if [[ -n "$check_cmd" ]]; then
            # Use custom check command
            if eval "$check_cmd"; then
                is_running=1
            else
                is_running=0
            fi
        else
            # Fall back to brew services list
            is_running=$(brew services list 2>/dev/null | grep "^$name " | grep -c "started" || true)
        fi

        if [[ "$is_running" -gt 0 ]]; then
            success "$name service already running"
        else
            info "Starting $name service..."
            if [[ "$use_sudo" == "true" ]]; then
                if sudo brew services start "$name"; then
                    success "Started $name"
                else
                    warn "Failed to start $name"
                fi
            else
                if brew services start "$name"; then
                    success "Started $name"
                else
                    warn "Failed to start $name"
                fi
            fi
        fi

        # Run post-start commands
        local post_start
        post_start=$(echo "$svc_json" | jq -r '.post_start // empty')
        if [[ -n "$post_start" ]]; then
            info "Running post-start for $name..."
            if eval "$post_start"; then
                success "Post-start complete for $name"
            else
                warn "Post-start failed for $name"
            fi
        fi
    done <<< "$services"
}

cmd_service() {
    local subcmd="${1:-}"
    shift || true

    case "$subcmd" in
        start)
            _start_services
            ;;
        list)
            if [[ -f "$SERVICES_FILE" ]]; then
                echo -e "${BLUE}=== Managed Services ===${NC}"
                jq -r '.[] | "\(.name) (sudo: \(.sudo // false))"' "$SERVICES_FILE"
            else
                echo "No services configured"
            fi
            echo ""
            echo -e "${BLUE}=== Running Brew Services ===${NC}"
            brew services list
            ;;
        *)
            error "Usage: dot service <start|list>"
            return 1
            ;;
    esac
}

# =============================================================================
# Pmset Helpers
# =============================================================================

PMSET_FILE="$SETTINGS_DIR/pmset.json"

cmd_pmset() {
    local subcmd="${1:-apply}"

    case "$subcmd" in
        apply)
            if [[ ! -f "$PMSET_FILE" ]]; then
                warn "No pmset.json found"
                return 0
            fi

            local settings
            settings=$(jq -r 'to_entries[] | "\(.key) \(.value)"' "$PMSET_FILE")

            if [[ -z "$settings" ]]; then
                return 0
            fi

            info "Checking pmset settings..."

            local needs_change=false

            while IFS= read -r line; do
                local key value current
                key=$(echo "$line" | awk '{print $1}')
                value=$(echo "$line" | awk '{print $2}')
                current=$(pmset -g | grep -E "^\s*$key\s+" | awk '{print $2}')

                if [[ "$current" == "$value" ]]; then
                    success "$key already set to $value"
                else
                    needs_change=true
                    info "Setting $key=$value (was $current)"
                    if sudo pmset -c "$key" "$value"; then
                        success "Set $key=$value"
                    else
                        warn "Failed to set $key=$value"
                    fi
                fi
            done <<< "$settings"

            if [[ "$needs_change" == false ]]; then
                success "All pmset settings already correct"
            else
                success "pmset settings applied"
            fi
            ;;
        show)
            echo -e "${BLUE}=== Current pmset Settings ===${NC}"
            pmset -g
            echo ""
            if [[ -f "$PMSET_FILE" ]]; then
                echo -e "${BLUE}=== Configured Settings (settings/pmset.json) ===${NC}"
                jq '.' "$PMSET_FILE"
            fi
            ;;
        *)
            error "Usage: dot pmset [apply|show]"
            return 1
            ;;
    esac
}

# =============================================================================
# Defaults Helpers
# =============================================================================

DEFAULTS_FILE="$SETTINGS_DIR/defaults.json"

# Map domains to apps that need restarting
_defaults_read() {
    gtimeout 3 defaults read "$1" "$2" 2>/dev/null
}

_defaults_write() {
    gtimeout 3 defaults write "$@" 2>/dev/null
}

_get_app_for_domain() {
    case "$1" in
        com.apple.finder) echo "Finder" ;;
        com.apple.dock) echo "Dock" ;;
        com.apple.SystemUIServer) echo "SystemUIServer" ;;
        com.apple.screencapture) echo "SystemUIServer" ;;
        com.apple.menuextra.clock) echo "SystemUIServer" ;;
        *) echo "" ;;
    esac
}

cmd_defaults() {
    local subcmd="${1:-apply}"

    case "$subcmd" in
        apply)
            if [[ ! -f "$DEFAULTS_FILE" ]]; then
                warn "No defaults.json found"
                return 0
            fi

            info "Checking macOS defaults..."

            local needs_change=false
            local apps_to_restart=()

            # Iterate over each domain
            local domains
            domains=$(jq -r 'keys[]' "$DEFAULTS_FILE")

            while IFS= read -r domain; do
                # Iterate over each key in the domain
                local keys
                keys=$(jq -r --arg d "$domain" '.[$d] | keys[]' "$DEFAULTS_FILE")

                while IFS= read -r key; do
                    local value value_type current
                    value=$(jq -r --arg d "$domain" --arg k "$key" '.[$d][$k]' "$DEFAULTS_FILE")
                    value_type=$(jq -r --arg d "$domain" --arg k "$key" '.[$d][$k] | type' "$DEFAULTS_FILE")

                    # Get current value (with timeout to handle corrupt containers)
                    current=$(_defaults_read "$domain" "$key")
                    if [[ $? -ne 0 ]] || [[ -z "$current" ]]; then
                        current="__NOT_SET__"
                    fi

                    # Convert JSON booleans to defaults format (1/0)
                    local expected="$value"
                    if [[ "$value_type" == "boolean" ]]; then
                        [[ "$value" == "true" ]] && expected="1" || expected="0"
                    fi

                    if [[ "$current" == "$expected" ]]; then
                        success "$domain $key already set to $expected"
                    else
                        needs_change=true
                        info "Setting $domain $key=$expected (was $current)"

                        # Write the value with appropriate type
                        case "$value_type" in
                            boolean)
                                _defaults_write "$domain" "$key" -bool "$value"
                                ;;
                            number)
                                # Check if it's an integer or float
                                if [[ "$value" =~ ^[0-9]+$ ]]; then
                                    _defaults_write "$domain" "$key" -int "$value"
                                else
                                    _defaults_write "$domain" "$key" -float "$value"
                                fi
                                ;;
                            *)
                                _defaults_write "$domain" "$key" -string "$value"
                                ;;
                        esac

                        success "Set $domain $key=$expected"

                        # Track app to restart
                        local app
                        app=$(_get_app_for_domain "$domain")
                        if [[ -n "$app" ]] && [[ ! " ${apps_to_restart[*]} " =~ " $app " ]]; then
                            apps_to_restart+=("$app")
                        fi
                    fi
                done <<< "$keys"
            done <<< "$domains"

            # Restart affected apps
            if [[ ${#apps_to_restart[@]} -gt 0 ]]; then
                info "Restarting affected apps: ${apps_to_restart[*]}"
                for app in "${apps_to_restart[@]}"; do
                    killall "$app" 2>/dev/null || true
                done
            fi

            if [[ "$needs_change" == false ]]; then
                success "All macOS defaults already correct"
            else
                success "macOS defaults applied"
            fi
            ;;
        show)
            echo -e "${BLUE}=== Configured Defaults (settings/defaults.json) ===${NC}"
            if [[ -f "$DEFAULTS_FILE" ]]; then
                jq '.' "$DEFAULTS_FILE"
            else
                echo "(no config file)"
            fi
            ;;
        *)
            error "Usage: dot defaults [apply|show]"
            return 1
            ;;
    esac
}

# =============================================================================
# Keyboard Helpers
# =============================================================================

KEYBOARD_FILE="$SETTINGS_DIR/keyboard.json"

# Map key names to HID usage codes
_get_hid_code() {
    case "$1" in
        caps_lock) echo "0x700000039" ;;
        escape) echo "0x700000029" ;;
        control) echo "0x7000000E0" ;;
        left_control) echo "0x7000000E0" ;;
        right_control) echo "0x7000000E4" ;;
        left_shift) echo "0x7000000E1" ;;
        right_shift) echo "0x7000000E5" ;;
        left_option) echo "0x7000000E2" ;;
        right_option) echo "0x7000000E6" ;;
        left_command) echo "0x7000000E3" ;;
        right_command) echo "0x7000000E7" ;;
        *) echo "" ;;
    esac
}

cmd_keyboard() {
    local subcmd="${1:-apply}"

    case "$subcmd" in
        apply)
            if [[ ! -f "$KEYBOARD_FILE" ]]; then
                warn "No keyboard.json found"
                return 0
            fi

            info "Applying keyboard remappings..."

            local remaps_count
            remaps_count=$(jq '.remaps | length' "$KEYBOARD_FILE")

            if [[ "$remaps_count" -eq 0 ]]; then
                info "No remappings configured"
                return 0
            fi

            # Build the hidutil mapping array
            local mappings="["
            local first=true

            for i in $(seq 0 $((remaps_count - 1))); do
                local from to from_code to_code comment
                from=$(jq -r ".remaps[$i].from" "$KEYBOARD_FILE")
                to=$(jq -r ".remaps[$i].to" "$KEYBOARD_FILE")
                comment=$(jq -r ".remaps[$i].comment // empty" "$KEYBOARD_FILE")

                from_code=$(_get_hid_code "$from")
                to_code=$(_get_hid_code "$to")

                if [[ -z "$from_code" || -z "$to_code" ]]; then
                    warn "Unknown key: $from or $to"
                    continue
                fi

                [[ "$first" == true ]] || mappings+=","
                first=false

                mappings+="{\"HIDKeyboardModifierMappingSrc\":$from_code,\"HIDKeyboardModifierMappingDst\":$to_code}"
                info "Mapping $from → $to${comment:+ ($comment)}"
            done

            mappings+="]"

            # Apply the remappings
            if hidutil property --set "{\"UserKeyMapping\":$mappings}" >/dev/null; then
                success "Keyboard remappings applied"
            else
                warn "Failed to apply keyboard remappings"
            fi
            ;;
        show)
            echo -e "${BLUE}=== Current Keyboard Remappings ===${NC}"
            hidutil property --get "UserKeyMapping" 2>/dev/null || echo "(none)"
            echo ""
            if [[ -f "$KEYBOARD_FILE" ]]; then
                echo -e "${BLUE}=== Configured Remappings (settings/keyboard.json) ===${NC}"
                jq '.remaps[] | "\(.from) → \(.to)\(if .comment then " (\(.comment))" else "" end)"' -r "$KEYBOARD_FILE"
            fi
            ;;
        *)
            error "Usage: dot keyboard [apply|show]"
            return 1
            ;;
    esac
}

# =============================================================================
# Commands
# =============================================================================

cmd_init() {
    info "Initializing dotfiles..."

    # Install Homebrew if needed
    if ! has brew; then
        info "Installing Homebrew..."
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
        eval "$(/opt/homebrew/bin/brew shellenv)"
    else
        success "Homebrew already installed"
    fi

    # Install stow if needed
    if ! has stow; then
        info "Installing GNU Stow..."
        brew install stow
    else
        success "GNU Stow already installed"
    fi

    # Install brew packages
    if [[ -f "$PACKAGES_DIR/Brewfile" ]]; then
        info "Installing packages from Brewfile..."
        brew bundle --file="$PACKAGES_DIR/Brewfile" || warn "Some packages failed to install"
    fi

    # Install profile-specific brew packages
    local profile
    profile=$(_get_profile)
    if [[ "$profile" == "personal" && -f "$PACKAGES_DIR/Brewfile.personal" ]]; then
        info "Installing packages from Brewfile.personal..."
        brew bundle --file="$PACKAGES_DIR/Brewfile.personal" || warn "Some personal packages failed to install"
    elif [[ "$profile" == "work" && -f "$PACKAGES_DIR/Brewfile.work" ]]; then
        info "Installing packages from Brewfile.work..."
        brew bundle --file="$PACKAGES_DIR/Brewfile.work" || warn "Some work packages failed to install"
    fi

    # Install bash packages
    _install_bash_packages

    # Install git hooks
    _install_git_hooks

    # Stow dotfiles (includes merge)
    cmd_stow

    # Start managed services
    _start_services

    # Apply system settings
    cmd_pmset apply || warn "pmset settings could not be applied"
    cmd_defaults apply || warn "macOS defaults could not be applied"
    cmd_keyboard apply || warn "keyboard remappings could not be applied"

    success "Initialization complete!"
}

_install_git_hooks() {
    local hooks_dir="$DOTFILES_DIR/.git/hooks"
    local hook_script="$SCRIPTS_DIR/git-hook-merge.sh"

    for hook in post-checkout post-merge; do
        local hook_path="$hooks_dir/$hook"
        if [[ ! -L "$hook_path" ]] || [[ "$(readlink "$hook_path")" != "$hook_script" ]]; then
            ln -sf "$hook_script" "$hook_path"
            info "Installed $hook hook"
        fi
    done
}

cmd_stow() {
    local clean=false
    [[ "${1:-}" == "--clean" || "${1:-}" == "-c" ]] && clean=true

    info "Stowing dotfiles..."

    cd "$DOTFILES_DIR"

    # Merge configs before stowing
    cmd_merge 2>/dev/null || true

    # Remove nested .git directories (excluding marketplaces)
    _clean_nested_git

    if [[ "$clean" == true ]]; then
        info "Clean mode: removing managed directories..."
        for path in "${SYMLINKS[@]}"; do
            if [[ -e "$path" && ! -L "$path" ]]; then
                rm -rf "$path"
                info "Removed: $path"
            fi
        done
    fi

    # Create directory symlinks from $HOME to dotfiles
    stow -v --target="$HOME" --dir="$DOTFILES_DIR" home

    success "Dotfiles stowed successfully"
}

_clean_nested_git() {
    # Remove .git directories only at the root of stow-managed directories
    for link in "${SYMLINKS[@]}"; do
        local rel_path="${link#$HOME/}"
        local git_dir="$DOTFILES_DIR/home/$rel_path/.git"
        if [[ -d "$git_dir" ]]; then
            rm -rf "$git_dir"
            info "Removed nested .git: home/$rel_path/.git"
        fi
    done
}

cmd_unstow() {
    info "Unstowing dotfiles..."
    cd "$DOTFILES_DIR"
    stow -v --delete --target="$HOME" --dir="$DOTFILES_DIR" home
    success "Dotfiles unstowed"
}

cmd_update() {
    info "Updating dotfiles..."

    cd "$DOTFILES_DIR"

    # Pull latest changes
    if git diff-index --quiet HEAD --; then
        git pull --rebase
    else
        warn "Local changes detected, stashing..."
        git stash
        git pull --rebase
        git stash pop
    fi

    # Update packages if requested
    if [[ "${1:-}" == "--packages" ]]; then
        info "Updating Homebrew packages..."
        brew update && brew upgrade
    fi

    # Merge configs and re-stow
    cmd_merge || warn "Config merge had issues"
    cmd_stow

    success "Update complete"
}

cmd_doctor() {
    info "Running diagnostics..."
    local issues=0

    # Check Homebrew
    if has brew; then
        success "Homebrew: installed"
    else
        error "Homebrew: not installed"
        issues=$((issues + 1))
    fi

    # Check Stow
    if has stow; then
        success "GNU Stow: installed"
    else
        error "GNU Stow: not installed"
        issues=$((issues + 1))
    fi

    # Check Fish
    if has fish; then
        success "Fish shell: installed"
    else
        warn "Fish shell: not installed"
    fi

    # Check Neovim
    if has nvim; then
        success "Neovim: installed"
    else
        warn "Neovim: not installed"
    fi

    # Check tmux
    if has tmux; then
        success "tmux: installed"
    else
        warn "tmux: not installed"
    fi

    # Check symlinks
    info "Checking symlinks..."

    for link in "${SYMLINKS[@]}"; do
        if [[ -L "$link" ]]; then
            success "Symlink OK: $link"
        elif [[ -e "$link" ]]; then
            warn "Not a symlink: $link"
        else
            warn "Missing: $link"
        fi
    done

    # Check config merging
    info "Checking config merging..."
    local profile_file="$DOTFILES_DIR/.dotprofile"
    if [[ -f "$profile_file" ]]; then
        local profile
        profile=$(cat "$profile_file" | tr -d '[:space:]')
        if [[ "$profile" == "work" || "$profile" == "personal" ]]; then
            success "Profile: $profile"
        else
            warn "Invalid profile value: $profile (should be 'work' or 'personal')"
        fi
    else
        warn "No .dotprofile found (run 'echo work > $profile_file' or 'echo personal > $profile_file')"
    fi

    # Check for base files without generated output
    local base_files
    base_files=$(find "$DOTFILES_DIR/home" -name "*.base.json" -type f 2>/dev/null || true)
    if [[ -n "$base_files" ]]; then
        while IFS= read -r base_file; do
            local name="${base_file%.base.json}"
            if [[ -f "${name}.json" ]]; then
                success "Generated: ${name}.json"
            else
                warn "Missing generated: ${name}.json (run 'dot merge')"
                issues=$((issues + 1))
            fi
        done <<< "$base_files"
    fi

    if [[ $issues -eq 0 ]]; then
        success "All checks passed!"
    else
        error "$issues issue(s) found"
        return 1
    fi
}

cmd_edit() {
    local editor="${EDITOR:-nvim}"
    cd "$DOTFILES_DIR"
    $editor .
}

cmd_package() {
    local subcmd="${1:-}"
    shift || true

    # Parse --personal and --work flags
    local personal=false
    local work=false
    local args=()
    for arg in "$@"; do
        case "$arg" in
            --personal) personal=true ;;
            --work) work=true ;;
            *) args+=("$arg") ;;
        esac
    done

    local brewfile bash_pkg_file
    if [[ "$personal" == true ]]; then
        brewfile="$PACKAGES_DIR/Brewfile.personal"
        bash_pkg_file="$BASH_PACKAGES_PERSONAL_FILE"
    elif [[ "$work" == true ]]; then
        brewfile="$PACKAGES_DIR/Brewfile.work"
        bash_pkg_file="$BASH_PACKAGES_WORK_FILE"
    else
        brewfile="$PACKAGES_DIR/Brewfile"
        bash_pkg_file="$BASH_PACKAGES_FILE"
    fi

    case "$subcmd" in
        add)
            local pkg="${args[0]:-}"
            local install_script="${args[1]:-}"

            if [[ -z "$pkg" ]]; then
                error "Usage: dot package add <package> [--personal|--work]"
                error "       dot package add <name> \"<install-script>\" [--personal|--work]"
                return 1
            fi

            # Two args = bash package, one arg = brew package
            if [[ -n "$install_script" ]]; then
                _ensure_bash_packages_file "$bash_pkg_file"

                if _bash_package_exists "$pkg" "$bash_pkg_file"; then
                    error "Package '$pkg' already exists in $(basename "$bash_pkg_file")"
                    return 1
                fi

                info "Adding bash package '$pkg' to $(basename "$bash_pkg_file")..."
                _add_bash_package "$pkg" "$install_script" "$bash_pkg_file"

                if ! has "$pkg"; then
                    info "Installing $pkg..."
                    echo "  Running: $install_script"
                    eval "$install_script" || warn "Installation may have failed"
                else
                    success "$pkg is already installed"
                fi
                success "Added bash package: $pkg"
            else
                # Brew package (existing behavior)
                local pkg_type="brew"
                if brew info --cask "$pkg" &>/dev/null; then
                    pkg_type="cask"
                fi

                info "Adding $pkg ($pkg_type) to $(basename "$brewfile")..."
                echo "$pkg_type \"$pkg\"" >> "$brewfile"

                if [[ "$pkg_type" == "cask" ]]; then
                    brew install --cask "$pkg"
                else
                    brew install "$pkg"
                fi
                success "Added $pkg"
            fi
            ;;
        remove)
            local pkg="${args[0]:-}"
            if [[ -z "$pkg" ]]; then
                error "Usage: dot package remove <package> [--personal|--work]"
                return 1
            fi

            # Check bash packages first (both files)
            if _bash_package_exists "$pkg" "$BASH_PACKAGES_FILE"; then
                info "Removing bash package '$pkg' from bash-packages.json..."
                _remove_bash_package "$pkg" "$BASH_PACKAGES_FILE"
                success "Removed bash package: $pkg"
                info "Note: The command '$pkg' remains installed on your system"
            elif _bash_package_exists "$pkg" "$BASH_PACKAGES_PERSONAL_FILE"; then
                info "Removing bash package '$pkg' from bash-packages.personal.json..."
                _remove_bash_package "$pkg" "$BASH_PACKAGES_PERSONAL_FILE"
                success "Removed bash package: $pkg"
                info "Note: The command '$pkg' remains installed on your system"
            elif _bash_package_exists "$pkg" "$BASH_PACKAGES_WORK_FILE"; then
                info "Removing bash package '$pkg' from bash-packages.work.json..."
                _remove_bash_package "$pkg" "$BASH_PACKAGES_WORK_FILE"
                success "Removed bash package: $pkg"
                info "Note: The command '$pkg' remains installed on your system"
            else
                # Brew package removal
                info "Removing $pkg from $(basename "$brewfile")..."
                sed -i '' "/\"$pkg\"/d" "$brewfile"
                brew uninstall "$pkg" 2>/dev/null || brew uninstall --cask "$pkg" 2>/dev/null || warn "Package not installed"
                success "Removed $pkg"
            fi
            ;;
        install)
            local profile
            profile=$(_get_profile)

            # Always install base packages
            info "Installing from Brewfile..."
            brew bundle --file="$PACKAGES_DIR/Brewfile"

            # Install profile-specific brew packages
            if [[ "$profile" == "personal" && -f "$PACKAGES_DIR/Brewfile.personal" ]]; then
                info "Installing from Brewfile.personal..."
                brew bundle --file="$PACKAGES_DIR/Brewfile.personal"
            elif [[ "$profile" == "work" && -f "$PACKAGES_DIR/Brewfile.work" ]]; then
                info "Installing from Brewfile.work..."
                brew bundle --file="$PACKAGES_DIR/Brewfile.work"
            fi

            echo ""
            _install_bash_packages

            success "Installation complete"
            ;;
        list)
            echo -e "${BLUE}=== Brew Packages ===${NC}"
            if [[ -f "$brewfile" ]]; then
                cat "$brewfile"
            else
                echo "(none)"
            fi

            echo ""
            echo -e "${BLUE}=== Bash Packages ===${NC}"
            _ensure_bash_packages_file "$BASH_PACKAGES_FILE"

            local has_packages=false

            if [[ -f "$BASH_PACKAGES_FILE" ]]; then
                local count
                count=$(jq 'length' "$BASH_PACKAGES_FILE")
                if [[ "$count" -gt 0 ]]; then
                    has_packages=true
                    echo "Core (bash-packages.json):"
                    jq -r '.[] | "  \(.command): \(.install)"' "$BASH_PACKAGES_FILE"
                fi
            fi

            if [[ -f "$BASH_PACKAGES_PERSONAL_FILE" ]]; then
                local count
                count=$(jq 'length' "$BASH_PACKAGES_PERSONAL_FILE")
                if [[ "$count" -gt 0 ]]; then
                    has_packages=true
                    echo "Personal (bash-packages.personal.json):"
                    jq -r '.[] | "  \(.command): \(.install)"' "$BASH_PACKAGES_PERSONAL_FILE"
                fi
            fi

            if [[ -f "$BASH_PACKAGES_WORK_FILE" ]]; then
                local count
                count=$(jq 'length' "$BASH_PACKAGES_WORK_FILE")
                if [[ "$count" -gt 0 ]]; then
                    has_packages=true
                    echo "Work (bash-packages.work.json):"
                    jq -r '.[] | "  \(.command): \(.install)"' "$BASH_PACKAGES_WORK_FILE"
                fi
            fi

            if [[ "$has_packages" == false ]]; then
                echo "(none)"
            fi
            ;;
        *)
            error "Usage: dot package <add|remove|install|list> [package] [--personal|--work]"
            return 1
            ;;
    esac
}

cmd_link() {
    info "Installing dot command globally..."
    local link_path="$HOME/.local/bin/dot"

    mkdir -p "$HOME/.local/bin"

    if [[ -L "$link_path" ]]; then
        warn "Link already exists at $link_path"
    else
        ln -sf "$DOTFILES_DIR/dot" "$link_path"
        success "Linked dot to $link_path"
    fi
}

cmd_unlink() {
    info "Removing global dot command..."
    rm -f "$HOME/.local/bin/dot"
    success "Unlinked dot"
}

cmd_merge() {
    info "Merging config files..."

    local profile_file="$DOTFILES_DIR/.dotprofile"

    # Check profile exists
    if [[ ! -f "$profile_file" ]]; then
        warn "No profile set. Create $profile_file with 'work' or 'personal'"
    else
        info "Profile: $(cat "$profile_file")"
    fi

    # Find all *.base.json files in home/ and settings/
    local base_files
    base_files=$(find "$DOTFILES_DIR/home" "$SETTINGS_DIR" -name "*.base.json" -type f 2>/dev/null || true)

    if [[ -z "$base_files" ]]; then
        info "No config files to merge (no *.base.json files found)"
        return 0
    fi

    local count=0
    local errors=0

    while IFS= read -r base_file; do
        if "$SCRIPTS_DIR/merge-config.sh" "$base_file"; then
            count=$((count + 1))
        else
            errors=$((errors + 1))
        fi
    done <<< "$base_files"

    if [[ $errors -eq 0 ]]; then
        success "Merged $count config file(s)"
    else
        error "Completed with $errors error(s)"
        return 1
    fi
}

cmd_backup() {
    info "Backing up existing configs to $BACKUP_DIR..."

    mkdir -p "$BACKUP_DIR"

    local backed_up=0

    for path in "${SYMLINKS[@]}"; do
        if [[ -L "$path" ]]; then
            # Already a symlink (managed by stow), skip
            info "Skipping $path (already a symlink)"
        elif [[ -e "$path" ]]; then
            # Real file/directory exists, back it up
            local rel_path="${path#$HOME/}"
            local backup_path="$BACKUP_DIR/$rel_path"
            local backup_parent
            backup_parent=$(dirname "$backup_path")

            mkdir -p "$backup_parent"
            rm -rf "$backup_path"  # Remove old backup if exists
            cp -a "$path" "$backup_path"
            success "Backed up: $path"
            backed_up=$((backed_up + 1))
        else
            info "Skipping $path (does not exist)"
        fi
    done

    if [[ $backed_up -eq 0 ]]; then
        info "Nothing to backup (all paths are symlinks or don't exist)"
    else
        success "Backed up $backed_up directory(ies) to $BACKUP_DIR"
    fi
}

cmd_restore() {
    if [[ "${1:-}" == "--list" ]]; then
        info "Backup contents in $BACKUP_DIR:"
        if [[ -d "$BACKUP_DIR" ]]; then
            find "$BACKUP_DIR" -mindepth 1 -maxdepth 2 -type d | while read -r dir; do
                echo "  ${dir#$BACKUP_DIR/}"
            done
        else
            warn "No backup directory found"
        fi
        return 0
    fi

    if [[ ! -d "$BACKUP_DIR" ]]; then
        error "No backup found at $BACKUP_DIR"
        error "Run 'dot backup' first to create a backup"
        return 1
    fi

    if [[ "${1:-}" == "--merge" ]]; then
        info "Merging extra files from backup (skipping files in dotfiles repo)..."
        local merged=0

        # Find all files in backup
        while IFS= read -r -d '' backup_file; do
            local rel_path="${backup_file#$BACKUP_DIR/}"
            local repo_file="$DOTFILES_DIR/home/$rel_path"
            local target_file="$HOME/$rel_path"

            # Only copy if file doesn't exist in dotfiles repo
            if [[ ! -e "$repo_file" ]]; then
                local target_dir
                target_dir=$(dirname "$target_file")
                mkdir -p "$target_dir"
                cp -a "$backup_file" "$target_file"
                info "Restored: $rel_path"
                merged=$((merged + 1))
            fi
        done < <(find "$BACKUP_DIR" -type f \
            -not -path "*/node_modules/*" \
            -not -path "*/.git/*" \
            -print0)

        if [[ $merged -eq 0 ]]; then
            info "No extra files to restore"
        else
            success "Restored $merged extra file(s)"
        fi
        return 0
    fi

    info "Restoring configs from $BACKUP_DIR..."

    # Unstow first to remove symlinks
    cmd_unstow 2>/dev/null || true

    local restored=0

    for path in "${SYMLINKS[@]}"; do
        local rel_path="${path#$HOME/}"
        local backup_path="$BACKUP_DIR/$rel_path"

        if [[ -e "$backup_path" ]]; then
            rm -rf "$path"  # Remove existing (symlink or dir)
            cp -a "$backup_path" "$path"
            success "Restored: $path"
            restored=$((restored + 1))
        fi
    done

    if [[ $restored -eq 0 ]]; then
        warn "No matching backups found to restore"
    else
        success "Restored $restored directory(ies)"
    fi
}

cmd_help() {
    cat << EOF
dot - Dotfiles management CLI

Usage: dot <command> [options]

Commands:
  init              Full setup: brew, packages, stow, config
  stow [-c|--clean] Create symlinks (--clean removes dirs first)
  unstow            Remove symlinks
  update [--packages]  Pull repo, optionally update packages, re-stow
  doctor            Check installation health
  edit              Open dotfiles in editor
  package <subcmd>  Manage packages (brew and bash)
    add <pkg>               Add brew package (auto-detects brew/cask)
    add <name> "<script>"   Add bash package with install script
    remove <pkg>            Remove package (checks bash first, then brew)
    install                 Install packages based on .dotprofile
    list                    List all packages
    (add --personal or --work to target profile-specific files)
  merge             Merge config files (*.base.json -> *.json)
  service <subcmd>  Manage brew services
    start                   Start services from services.json
    list                    List configured and running services
  pmset [apply|show]  Manage power settings
  defaults [apply|show]  Manage macOS defaults
  keyboard [apply|show]  Manage keyboard remappings
  backup            Backup existing configs before stow
  restore [--list|--merge]  Restore configs (--merge only restores extra files)
  link              Install dot to /usr/local/bin
  unlink            Remove dot from /usr/local/bin
  help              Show this help message

Environment:
  DOTFILES_DIR      Override dotfiles directory (default: ~/.dotfiles)
  EDITOR            Editor for 'dot edit' command (default: nvim)
EOF
}

# =============================================================================
# Main
# =============================================================================

main() {
    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        init)    cmd_init "$@" ;;
        stow)    cmd_stow "$@" ;;
        unstow)  cmd_unstow "$@" ;;
        update)  cmd_update "$@" ;;
        doctor)  cmd_doctor "$@" ;;
        edit)    cmd_edit "$@" ;;
        package) cmd_package "$@" ;;
        merge)   cmd_merge "$@" ;;
        service) cmd_service "$@" ;;
        pmset)   cmd_pmset "$@" ;;
        defaults) cmd_defaults "$@" ;;
        keyboard) cmd_keyboard "$@" ;;
        backup)  cmd_backup "$@" ;;
        restore) cmd_restore "$@" ;;
        link)    cmd_link "$@" ;;
        unlink)  cmd_unlink "$@" ;;
        help|--help|-h) cmd_help ;;
        *)
            error "Unknown command: $cmd"
            cmd_help
            return 1
            ;;
    esac
}

main "$@"
