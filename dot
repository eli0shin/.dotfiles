#!/usr/bin/env bash
set -euo pipefail

# Dotfiles management CLI
# Inspired by dmmulroy/.dotfiles

DOTFILES_DIR="${DOTFILES_DIR:-$HOME/.dotfiles}"
PACKAGES_DIR="$DOTFILES_DIR/packages"
SCRIPTS_DIR="$DOTFILES_DIR/scripts"
BACKUP_DIR="$HOME/.dotfiles-backup"

# Managed symlink directories
SYMLINKS=(
    "$HOME/.config/nvim"
    "$HOME/.config/fish"
    "$HOME/.config/tmux"
    "$HOME/.config/ghostty"
    "$HOME/.config/git"
    "$HOME/.config/omf"
    "$HOME/.config/opencode"
    "$HOME/.claude"
)

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging helpers
info() { echo -e "${BLUE}[INFO]${NC} $1"; }
success() { echo -e "${GREEN}[OK]${NC} $1"; }
warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Check if command exists
has() { command -v "$1" &>/dev/null; }

# =============================================================================
# Bash Package Helpers
# =============================================================================

BASH_PACKAGES_FILE="$PACKAGES_DIR/bash-packages.json"
BASH_PACKAGES_PERSONAL_FILE="$PACKAGES_DIR/bash-packages.personal.json"

_ensure_bash_packages_file() {
    local file="$1"
    if [[ ! -f "$file" ]]; then
        echo "[]" > "$file"
    fi
}

_bash_package_exists() {
    local pkg="$1"
    local file="$2"
    _ensure_bash_packages_file "$file"
    jq -e --arg cmd "$pkg" 'any(.[]; .command == $cmd)' "$file" >/dev/null 2>&1
}

_add_bash_package() {
    local pkg="$1"
    local install_script="$2"
    local file="$3"
    _ensure_bash_packages_file "$file"
    local tmp
    tmp=$(jq --arg cmd "$pkg" --arg inst "$install_script" \
        '. + [{"command": $cmd, "install": $inst}]' "$file")
    echo "$tmp" > "$file"
}

_remove_bash_package() {
    local pkg="$1"
    local file="$2"
    _ensure_bash_packages_file "$file"
    local tmp
    tmp=$(jq --arg cmd "$pkg" 'map(select(.command != $cmd))' "$file")
    echo "$tmp" > "$file"
}

_get_profile() {
    local profile_file="$DOTFILES_DIR/.dotprofile"
    if [[ -f "$profile_file" ]]; then
        cat "$profile_file" | tr -d '[:space:]'
    else
        echo ""
    fi
}

_install_bash_packages() {
    info "Installing bash packages..."

    local profile
    profile=$(_get_profile)

    _process_bash_packages_file "$BASH_PACKAGES_FILE"

    if [[ "$profile" == "personal" ]]; then
        if [[ -f "$BASH_PACKAGES_PERSONAL_FILE" ]]; then
            _process_bash_packages_file "$BASH_PACKAGES_PERSONAL_FILE"
        fi
    fi
}

_process_bash_packages_file() {
    local file="$1"

    if [[ ! -f "$file" ]]; then
        return 0
    fi

    local count
    count=$(jq 'length' "$file")

    if [[ "$count" -eq 0 ]]; then
        return 0
    fi

    info "Processing $(basename "$file")..."

    local packages
    packages=$(jq -c '.[]' "$file")

    while IFS= read -r pkg_json; do
        local cmd install_script
        cmd=$(echo "$pkg_json" | jq -r '.command')
        install_script=$(echo "$pkg_json" | jq -r '.install')

        if has "$cmd"; then
            success "$cmd already installed"
        else
            info "Installing $cmd..."
            echo "  Running: $install_script"
            if eval "$install_script"; then
                success "Installed $cmd"
            else
                warn "Failed to install $cmd (continuing...)"
            fi
        fi
    done <<< "$packages"
}

# =============================================================================
# Commands
# =============================================================================

cmd_init() {
    info "Initializing dotfiles..."

    # Install Homebrew if needed
    if ! has brew; then
        info "Installing Homebrew..."
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
        eval "$(/opt/homebrew/bin/brew shellenv)"
    else
        success "Homebrew already installed"
    fi

    # Install stow if needed
    if ! has stow; then
        info "Installing GNU Stow..."
        brew install stow
    else
        success "GNU Stow already installed"
    fi

    # Install brew packages
    if [[ -f "$PACKAGES_DIR/Brewfile" ]]; then
        info "Installing packages from Brewfile..."
        brew bundle --file="$PACKAGES_DIR/Brewfile" || warn "Some packages failed to install"
    fi

    # Install bash packages
    _install_bash_packages

    # Install git hooks
    _install_git_hooks

    # Merge configs and stow dotfiles
    cmd_merge || warn "Config merge had issues"
    cmd_stow

    success "Initialization complete!"
}

_install_git_hooks() {
    local hooks_dir="$DOTFILES_DIR/.git/hooks"
    local hook_script="$SCRIPTS_DIR/git-hook-merge.sh"

    for hook in post-checkout post-merge; do
        local hook_path="$hooks_dir/$hook"
        if [[ ! -L "$hook_path" ]] || [[ "$(readlink "$hook_path")" != "$hook_script" ]]; then
            ln -sf "$hook_script" "$hook_path"
            info "Installed $hook hook"
        fi
    done
}

cmd_stow() {
    info "Stowing dotfiles..."

    cd "$DOTFILES_DIR"

    # Merge configs before stowing
    cmd_merge 2>/dev/null || true

    # Create directory symlinks from $HOME to dotfiles
    stow -v --target="$HOME" --dir="$DOTFILES_DIR" home

    success "Dotfiles stowed successfully"
}

cmd_unstow() {
    info "Unstowing dotfiles..."
    cd "$DOTFILES_DIR"
    stow -v --delete --target="$HOME" --dir="$DOTFILES_DIR" home
    success "Dotfiles unstowed"
}

cmd_update() {
    info "Updating dotfiles..."

    cd "$DOTFILES_DIR"

    # Pull latest changes
    if git diff-index --quiet HEAD --; then
        git pull --rebase
    else
        warn "Local changes detected, stashing..."
        git stash
        git pull --rebase
        git stash pop
    fi

    # Update packages if requested
    if [[ "${1:-}" == "--packages" ]]; then
        info "Updating Homebrew packages..."
        brew update && brew upgrade
    fi

    # Merge configs and re-stow
    cmd_merge || warn "Config merge had issues"
    cmd_stow

    success "Update complete"
}

cmd_doctor() {
    info "Running diagnostics..."
    local issues=0

    # Check Homebrew
    if has brew; then
        success "Homebrew: installed"
    else
        error "Homebrew: not installed"
        issues=$((issues + 1))
    fi

    # Check Stow
    if has stow; then
        success "GNU Stow: installed"
    else
        error "GNU Stow: not installed"
        issues=$((issues + 1))
    fi

    # Check Fish
    if has fish; then
        success "Fish shell: installed"
    else
        warn "Fish shell: not installed"
    fi

    # Check Neovim
    if has nvim; then
        success "Neovim: installed"
    else
        warn "Neovim: not installed"
    fi

    # Check tmux
    if has tmux; then
        success "tmux: installed"
    else
        warn "tmux: not installed"
    fi

    # Check symlinks
    info "Checking symlinks..."

    for link in "${SYMLINKS[@]}"; do
        if [[ -L "$link" ]]; then
            success "Symlink OK: $link"
        elif [[ -e "$link" ]]; then
            warn "Not a symlink: $link"
        else
            warn "Missing: $link"
        fi
    done

    # Check config merging
    info "Checking config merging..."
    local profile_file="$DOTFILES_DIR/.dotprofile"
    if [[ -f "$profile_file" ]]; then
        local profile
        profile=$(cat "$profile_file" | tr -d '[:space:]')
        if [[ "$profile" == "work" || "$profile" == "personal" ]]; then
            success "Profile: $profile"
        else
            warn "Invalid profile value: $profile (should be 'work' or 'personal')"
        fi
    else
        warn "No .dotprofile found (run 'echo work > $profile_file' or 'echo personal > $profile_file')"
    fi

    # Check for base files without generated output
    local base_files
    base_files=$(find "$DOTFILES_DIR/home" -name "*.base.json" -type f 2>/dev/null || true)
    if [[ -n "$base_files" ]]; then
        while IFS= read -r base_file; do
            local name="${base_file%.base.json}"
            if [[ -f "${name}.json" ]]; then
                success "Generated: ${name}.json"
            else
                warn "Missing generated: ${name}.json (run 'dot merge')"
                issues=$((issues + 1))
            fi
        done <<< "$base_files"
    fi

    if [[ $issues -eq 0 ]]; then
        success "All checks passed!"
    else
        error "$issues issue(s) found"
        return 1
    fi
}

cmd_edit() {
    local editor="${EDITOR:-nvim}"
    cd "$DOTFILES_DIR"
    $editor .
}

cmd_package() {
    local subcmd="${1:-}"
    shift || true

    # Parse --personal flag
    local personal=false
    local args=()
    for arg in "$@"; do
        case "$arg" in
            --personal) personal=true ;;
            *) args+=("$arg") ;;
        esac
    done

    local brewfile bash_pkg_file
    if [[ "$personal" == true ]]; then
        brewfile="$PACKAGES_DIR/Brewfile.personal"
        bash_pkg_file="$BASH_PACKAGES_PERSONAL_FILE"
    else
        brewfile="$PACKAGES_DIR/Brewfile"
        bash_pkg_file="$BASH_PACKAGES_FILE"
    fi

    case "$subcmd" in
        add)
            local pkg="${args[0]:-}"
            local install_script="${args[1]:-}"

            if [[ -z "$pkg" ]]; then
                error "Usage: dot package add <package> [--personal]"
                error "       dot package add <name> \"<install-script>\" [--personal]"
                return 1
            fi

            # Two args = bash package, one arg = brew package
            if [[ -n "$install_script" ]]; then
                _ensure_bash_packages_file "$bash_pkg_file"

                if _bash_package_exists "$pkg" "$bash_pkg_file"; then
                    error "Package '$pkg' already exists in $(basename "$bash_pkg_file")"
                    return 1
                fi

                info "Adding bash package '$pkg' to $(basename "$bash_pkg_file")..."
                _add_bash_package "$pkg" "$install_script" "$bash_pkg_file"

                if ! has "$pkg"; then
                    info "Installing $pkg..."
                    echo "  Running: $install_script"
                    eval "$install_script" || warn "Installation may have failed"
                else
                    success "$pkg is already installed"
                fi
                success "Added bash package: $pkg"
            else
                # Brew package (existing behavior)
                local pkg_type="brew"
                if brew info --cask "$pkg" &>/dev/null; then
                    pkg_type="cask"
                fi

                info "Adding $pkg ($pkg_type) to $(basename "$brewfile")..."
                echo "$pkg_type \"$pkg\"" >> "$brewfile"

                if [[ "$pkg_type" == "cask" ]]; then
                    brew install --cask "$pkg"
                else
                    brew install "$pkg"
                fi
                success "Added $pkg"
            fi
            ;;
        remove)
            local pkg="${args[0]:-}"
            if [[ -z "$pkg" ]]; then
                error "Usage: dot package remove <package> [--personal]"
                return 1
            fi

            # Check bash packages first (both files)
            if _bash_package_exists "$pkg" "$BASH_PACKAGES_FILE"; then
                info "Removing bash package '$pkg' from bash-packages.json..."
                _remove_bash_package "$pkg" "$BASH_PACKAGES_FILE"
                success "Removed bash package: $pkg"
                info "Note: The command '$pkg' remains installed on your system"
            elif _bash_package_exists "$pkg" "$BASH_PACKAGES_PERSONAL_FILE"; then
                info "Removing bash package '$pkg' from bash-packages.personal.json..."
                _remove_bash_package "$pkg" "$BASH_PACKAGES_PERSONAL_FILE"
                success "Removed bash package: $pkg"
                info "Note: The command '$pkg' remains installed on your system"
            else
                # Brew package removal
                info "Removing $pkg from $(basename "$brewfile")..."
                sed -i '' "/\"$pkg\"/d" "$brewfile"
                brew uninstall "$pkg" 2>/dev/null || brew uninstall --cask "$pkg" 2>/dev/null || warn "Package not installed"
                success "Removed $pkg"
            fi
            ;;
        install)
            if [[ "$personal" == true ]]; then
                info "Installing from $(basename "$brewfile")..."
                brew bundle --file="$brewfile"
            elif [[ "${args[0]:-}" == "--all" ]]; then
                info "Installing from all Brewfiles..."
                brew bundle --file="$PACKAGES_DIR/Brewfile"
                [[ -f "$PACKAGES_DIR/Brewfile.personal" ]] && brew bundle --file="$PACKAGES_DIR/Brewfile.personal"
            else
                info "Installing from Brewfile..."
                brew bundle --file="$PACKAGES_DIR/Brewfile"
            fi

            echo ""
            _install_bash_packages

            success "Installation complete"
            ;;
        list)
            echo -e "${BLUE}=== Brew Packages ===${NC}"
            if [[ -f "$brewfile" ]]; then
                cat "$brewfile"
            else
                echo "(none)"
            fi

            echo ""
            echo -e "${BLUE}=== Bash Packages ===${NC}"
            _ensure_bash_packages_file "$BASH_PACKAGES_FILE"

            local has_packages=false

            if [[ -f "$BASH_PACKAGES_FILE" ]]; then
                local count
                count=$(jq 'length' "$BASH_PACKAGES_FILE")
                if [[ "$count" -gt 0 ]]; then
                    has_packages=true
                    echo "Core (bash-packages.json):"
                    jq -r '.[] | "  \(.command): \(.install)"' "$BASH_PACKAGES_FILE"
                fi
            fi

            if [[ -f "$BASH_PACKAGES_PERSONAL_FILE" ]]; then
                local count
                count=$(jq 'length' "$BASH_PACKAGES_PERSONAL_FILE")
                if [[ "$count" -gt 0 ]]; then
                    has_packages=true
                    echo "Personal (bash-packages.personal.json):"
                    jq -r '.[] | "  \(.command): \(.install)"' "$BASH_PACKAGES_PERSONAL_FILE"
                fi
            fi

            if [[ "$has_packages" == false ]]; then
                echo "(none)"
            fi
            ;;
        *)
            error "Usage: dot package <add|remove|install|list> [package] [--personal]"
            return 1
            ;;
    esac
}

cmd_link() {
    info "Installing dot command globally..."
    local link_path="/usr/local/bin/dot"

    if [[ -L "$link_path" ]]; then
        warn "Link already exists at $link_path"
    else
        sudo ln -sf "$DOTFILES_DIR/dot" "$link_path"
        success "Linked dot to $link_path"
    fi
}

cmd_unlink() {
    info "Removing global dot command..."
    sudo rm -f /usr/local/bin/dot
    success "Unlinked dot"
}

cmd_merge() {
    info "Merging config files..."

    local profile_file="$DOTFILES_DIR/.dotprofile"

    # Check profile exists
    if [[ ! -f "$profile_file" ]]; then
        warn "No profile set. Create $profile_file with 'work' or 'personal'"
    else
        info "Profile: $(cat "$profile_file")"
    fi

    # Find all *.base.json files in home/
    local base_files
    base_files=$(find "$DOTFILES_DIR/home" -name "*.base.json" -type f 2>/dev/null || true)

    if [[ -z "$base_files" ]]; then
        info "No config files to merge (no *.base.json files found)"
        return 0
    fi

    local count=0
    local errors=0

    while IFS= read -r base_file; do
        if "$SCRIPTS_DIR/merge-config.sh" "$base_file"; then
            count=$((count + 1))
        else
            errors=$((errors + 1))
        fi
    done <<< "$base_files"

    if [[ $errors -eq 0 ]]; then
        success "Merged $count config file(s)"
    else
        error "Completed with $errors error(s)"
        return 1
    fi
}

cmd_backup() {
    info "Backing up existing configs to $BACKUP_DIR..."

    mkdir -p "$BACKUP_DIR"

    local backed_up=0

    for path in "${SYMLINKS[@]}"; do
        if [[ -L "$path" ]]; then
            # Already a symlink (managed by stow), skip
            info "Skipping $path (already a symlink)"
        elif [[ -e "$path" ]]; then
            # Real file/directory exists, back it up
            local rel_path="${path#$HOME/}"
            local backup_path="$BACKUP_DIR/$rel_path"
            local backup_parent
            backup_parent=$(dirname "$backup_path")

            mkdir -p "$backup_parent"
            rm -rf "$backup_path"  # Remove old backup if exists
            cp -a "$path" "$backup_path"
            success "Backed up: $path"
            backed_up=$((backed_up + 1))
        else
            info "Skipping $path (does not exist)"
        fi
    done

    if [[ $backed_up -eq 0 ]]; then
        info "Nothing to backup (all paths are symlinks or don't exist)"
    else
        success "Backed up $backed_up directory(ies) to $BACKUP_DIR"
    fi
}

cmd_restore() {
    if [[ "${1:-}" == "--list" ]]; then
        info "Backup contents in $BACKUP_DIR:"
        if [[ -d "$BACKUP_DIR" ]]; then
            find "$BACKUP_DIR" -mindepth 1 -maxdepth 2 -type d | while read -r dir; do
                echo "  ${dir#$BACKUP_DIR/}"
            done
        else
            warn "No backup directory found"
        fi
        return 0
    fi

    if [[ ! -d "$BACKUP_DIR" ]]; then
        error "No backup found at $BACKUP_DIR"
        error "Run 'dot backup' first to create a backup"
        return 1
    fi

    info "Restoring configs from $BACKUP_DIR..."

    # Unstow first to remove symlinks
    cmd_unstow 2>/dev/null || true

    local restored=0

    for path in "${SYMLINKS[@]}"; do
        local rel_path="${path#$HOME/}"
        local backup_path="$BACKUP_DIR/$rel_path"

        if [[ -e "$backup_path" ]]; then
            rm -rf "$path"  # Remove existing (symlink or dir)
            cp -a "$backup_path" "$path"
            success "Restored: $path"
            restored=$((restored + 1))
        fi
    done

    if [[ $restored -eq 0 ]]; then
        warn "No matching backups found to restore"
    else
        success "Restored $restored directory(ies)"
    fi
}

cmd_help() {
    cat << EOF
dot - Dotfiles management CLI

Usage: dot <command> [options]

Commands:
  init              Full setup: brew, packages, stow
  stow              Create symlinks using GNU Stow
  unstow            Remove symlinks
  update [--packages]  Pull repo, optionally update packages, re-stow
  doctor            Check installation health
  edit              Open dotfiles in editor
  package <subcmd>  Manage packages (brew and bash)
    add <pkg>               Add brew package (auto-detects brew/cask)
    add <name> "<script>"   Add bash package with install script
    remove <pkg>            Remove package (checks bash first, then brew)
    install                 Install from Brewfile + bash-packages.json
    install --all           Install from all package files
    list                    List all packages
    (add --personal to target personal files)
  merge             Merge config files (*.base.json -> *.json)
  backup            Backup existing configs before stow
  restore [--list]  Restore configs from backup
  link              Install dot to /usr/local/bin
  unlink            Remove dot from /usr/local/bin
  help              Show this help message

Environment:
  DOTFILES_DIR      Override dotfiles directory (default: ~/.dotfiles)
  EDITOR            Editor for 'dot edit' command (default: nvim)
EOF
}

# =============================================================================
# Main
# =============================================================================

main() {
    local cmd="${1:-help}"
    shift || true

    case "$cmd" in
        init)    cmd_init "$@" ;;
        stow)    cmd_stow "$@" ;;
        unstow)  cmd_unstow "$@" ;;
        update)  cmd_update "$@" ;;
        doctor)  cmd_doctor "$@" ;;
        edit)    cmd_edit "$@" ;;
        package) cmd_package "$@" ;;
        merge)   cmd_merge "$@" ;;
        backup)  cmd_backup "$@" ;;
        restore) cmd_restore "$@" ;;
        link)    cmd_link "$@" ;;
        unlink)  cmd_unlink "$@" ;;
        help|--help|-h) cmd_help ;;
        *)
            error "Unknown command: $cmd"
            cmd_help
            return 1
            ;;
    esac
}

main "$@"
